### 解决问题：如何保证集群各节点上数据一致性



**在整个投票过程中我们可以提炼出四个最核心的概念**

- `候选人能力`：投票的基本原则是选最强的人
- `遇强改投`：如果后面发现更强的人可以改投票
- `投票箱`：所有人的票都会放在投票箱
- `领导者`：得票最多的人即为领导者



### Zab

> 基于 **主备模式（Leader / Follower）** 保证集群各节点数据一致性（**Raft** 也是 Leader / Follower）
>
> 主进程（Leader）负责 **写入** 客户端数据，然后 **复制** 到备份进程（Follower）
>
> 在两种状态间切换：**消息广播**、**崩溃恢复**

+ **消息广播**【类似 **2PC**】

  1. **prepare**：Leader 将数据 **预** 写入 自身 和 Followers
  2. **commit**：当超过半数 Follower 返回 ack，Leader 执行 commit（先 commit 自身，再发送 commit 给 Followers）

  + **Tips**
    + Zab协议 **保证客户端写请求的执行顺序**
      1. 为每个请求分配 **全局递增 ZXID**
      2. **只能 Leader 接受写请求**；Follwer 接收到写请求，将**转发**给 Leader 处理 
    + 对比 2PC 协议，Zab 在 Leader 和 Follower 间使用 **消息队列** 异步处理，解除同步阻塞

+ **奔溃恢复【选举 + 同步】**

  + **原则 / 要求**

    1. Leader 自身 commit 的数据最终会被 Followers **同步**

    2. Leader 没有 commit 的数据将确保被 **丢弃**

  + **基于 ZXID / SID 选举 Leader**

    + 事务编号、服务器编号**越大**，则在选举算法中权重越大（候选人能力）

  + **数据同步**

    + **场景**：在选举成功**后**，正式工作**前**，新 Leader 需确认 **自身事务** 是否被 **过半** Follower 提交

    + **策略**：Follower 接上 Leader 后，对比 自己 与 Leader 的 ZXID **编号大小**，进行**回滚或更新**。



### Raft

> 核心概念：选举任期、超过半数、节点状态【跟随者、候选者、领导者】

+ **Leader选举**：每个跟随着节点 **随机的选举超时** 时间，直到仅有一个节点 **最先** 发起候选投票，**超过半数** 节点同意则晋升为领导者。领导者是分布式系统的 **操作入口** 。

+ **日志复制流程**：客户端想更新数据，Leader **先记录**日志，此时状态为 **uncommitted**；并将日志同步给 Fllower节点，当超过半数节点同步日志时，Leader 状态变为 **commited** **再更新**数据；最后通知其它所有节点更新数据至集群状态一致。    

+ **网络分区容错**：不同分区下的节点会 **各自选举**，产生多个 Leader；当网络恢复正常时，选举任期高的 Leader 留下，其它 Leader 转化为 Follower，并根据 uncommitted 日志进行操作回滚；最后同步所有节点。

+ **故障转移执行者**

  > 当哨兵 ping redis-master 超过 ```is-master-down-after-milliseconds``` 时则主观认为 master 宕机，并通知其它哨兵。当某哨兵接收 **超过半数** 的宕机通知，则开启 **执行故障转移的哨兵选举** 流程。



### Paxos 【没有 Leader】