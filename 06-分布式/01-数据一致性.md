### Q：客户端往集群节点写数据，如何保证集群各节点上数据强一致性（CP）

<img src="pictures/image-20210406191557474.png" alt="image-20210406191557474" style="zoom:80%;" />



### Raft【Leader】

> 强一致 or 最终一致性
> http://hecenjie.cn/2020/02/09/%E5%AF%B9Raft%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/

#### 领导选举

> 三种角色：Leader、Follower 和 Candidate。所有客户端都与 Leader 进行交互。

1. 初始选举

   > 每个节点都有选举定时器，不同的**超时时间**。（超时时间需要大于Leader心跳间隔）
   >
   > 超时则节点发起选举（**候选先投自己一票**），获得投票数超集群节点数一半，则节点成为Leader。
   >
   > Follower跟随  Candidate候选 Leader领导

2. 故障转移

   > Leader故障，其它节点在**心跳间隔期**间没收到信号，则在选举定时器超时发起选举。（收到心跳则**重置**选举定时器）

3. 投票分裂

   > 任期号（Term）：Raft使用任期号来区分不同的Leader
   >
   > 5节点，其中S1宕机，S2 S3近乎同时发起选举，任期为1，**任期置给其它节点**
   >
   > S4只能将票投给S2或者S3（每一个任期号只能有一个Leader），S5同理
   >
   > 若S4投S2，S5投S3，则投票数均没过半，没形成Leader
   >
   > 接下去，假设S4选举超时，**任期自增为2**，此时S2/S3/S5均投票给S4（**遇强改投，任期越高越强**）

#### 日志复制

> **复制状态机**（日志复制）：Raft 中使用 **日志** 来记录所有操作，所有结点都有自己的日志列表来记录所有请求。区分 **日志** 与 **数据**
>
> **两段式提交**（一阶段写日志，二阶段写数据）：
>
> 1. Leader在收到来自客户端请求后并不会执行，只是将操作写入日志中，然后将该操作发送给所有的Follower
> 2. Follower在收到请求后写入日子，并回复Leader
> 3. 当有**超过半数**的结点写入日志后，Leader才会提交操作并返回给客户
> 4. 后续再通知所有其他结点提交操作（可以伴随1阶段写日志请求，携带2阶段提交请求）。

#### 安全性

> 日志持久化：只要提交过后的操作一定在**过半数的结点上持久化日志**，从而保证了数据不会丢失
>
> 过半数可确保即使重选Leader，其跟随者中必然有一个节点，存在最新的持久化日志
>
> 领导选举另外2个约束（满足以下条件之一则投赞成票）：
>
> 1. 候选人最后一条Log条目的任期号**大于**本地最后一条Log条目的任期号
> 2. 候选人最后一条Log条目的任期号**等于**本地最后一条Log条目的任期号，且候选人的Log记录长度**大于等于**本地Log记录的长度







### Zab【Leader】

> 类Raft协议，读性能更好
>
> 领导写，超半数提交，副本可读（故不提供强一致性，可能读取旧数据）
>
> 为每个请求分配 **全局递增** zxid，保证任意客户端写操作的全局顺序一致性

#### 领导选举

> 编号权重：epoch 任期 > counter 日志 > sid 服务器
>
> zxid 事务 = epoch.counter

#### 日志复制

> **两段式提交**（一阶段写日志，二阶段写数据）

#### ZK场景

```shell
# 实现计数器
WHILE TRUE:
    X, V = GETDATA("F")       # 从某个副本读到了一个数据X和一个版本号V，或许是旧的或许是最新的
    IF SETDATA("f", X + 1, V):  # SETDATA会在Leader节点执行，只有当实际真实的版本号等于V的时候，才更新数据。
        BREAK

# 实现非扩展锁
WHILE TRUE:
    IF CREATE("f", data, ephemeral=TRUE): RETURN  # 尝试创建锁文件。指定文件名和ephemeral为TRUE
    IF EXIST("f", watch=TRUE):  # 如果锁文件创建失败了，等待锁释放
        WAIT
# 羊群效应：如果有1000个客户端同时要获得锁文件，为1000个客户端分发锁所需要的时间是O(N^2)，因为每一次锁文件的释放，所有剩下的客户端都会收到WATCH的通知，并且回到循环的开始，所以CREATE操作次数N^2。

# 实现可扩展锁（避免羊群）
CREATE("f", data, sequential=TRUE, ephemeral=TRUE) # 创建了以f开头的Sequential文件，实际类似以“f27”为名字的文件
# 有两点需要注意，第一是通过CREATE，我们获得了一个全局唯一序列号（比如27），第二Zookeeper生成的序号必然是递增的。
WHILE TRUE:
    LIST("f*")                     # 过LIST列出了所有以“f”开头的文件，也就是所有的Sequential文件
    IF NO LOWER #FILE: RETURN      # 如果现存的Sequential文件的序列号都不小于我们在代码第1行得到的序列号，则获得锁
    IF EXIST(NEXT LOWER #FILE, watch=TRUE):   
        WAIT
# 常数：比如序列号为500的锁只会被序列号为501的客户端等待，而序列号500的客户端只会等待序列号499的锁文件。每个客户端只会等待一个锁文件，当一个锁文件被释放，只有下一个序列号对应的客户端才会收到通知。
```



### Paxos 【no Leader】

+ 角色：提议者、接受者、学习者
+ 阶段：准备阶段（编号）、接受阶段（提议）
+ 原则：
  1. 编号小的，优先级低，两个阶段的请求都会直接拒绝（准备阶段，越后面编号越大）
  2. 编号大的，优先级高，但准备阶段时，如果发送的接受者已经接收到编号小的提议（接受阶段），则编号大的会在准备阶段后将提议改为编号小的提议
  3. 少数服从多数
     + 提议者在准备阶段，只要接收超过半数回复，就可以进行接收阶段
     + 接收阶段，只要有过半数的接收者接受同一个提议，则达成共识

+ 示例：

  + 准备阶段：

    1. 发送请求：提议者B 在后面，编号大

       <img src="pictures/image-20210722154242364.png" alt="image-20210722154242364" style="zoom: 40%;" />

    2. 接收请求：

       1. 编号小的，优先级低，请求会直接拒绝（图中的❌）
       2. 编号大的覆盖编号小的（此时没触及原则2）
       3. 触及原则2的情况：
          + 假设 接收者Y 经过 提议者A 的提议阶段，状态是 [1,北]，此时 提议者B 的准备阶段发送 [2, 空]
          + 接收者Y 状态变更为 [2,北]，准备阶段的响应是 [2,北]
          + 提议者B 接收到响应后，发现已有提案（若有多个，取编号高的），就将自己的提议改为 北，接受阶段发送 [2, 北]

       <img src="pictures/image-20210722154351616.png" alt="image-20210722154351616" style="zoom:40%;" />

       <img src="pictures/image-20210722154736832.png" alt="image-20210722154736832" style="zoom:40%;" />

  + 接受阶段

    1. 发送请求：15点1分（提议者在准备阶段，只要接收超过半数回复，就可以进行接收阶段）

       <img src="pictures/image-20210722154926063.png" alt="image-20210722154926063" style="zoom:45%;" />

    2. 接收请求：

       1. 编号小的，优先级低，请求会直接拒绝（图中的❌）
       2. 少数服从多数（19点时即达成共识）

       <img src="pictures/image-20210722155425029.png" alt="image-20210722155425029" style="zoom:45%;" />