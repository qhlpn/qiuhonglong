https://gitee.com/moxi159753/LearningNotes/tree/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88

https://www.bilibili.com/video/BV1PJ411n7xZ?from=search&seid=15188220267839160314

## JVM

<img src="pictures/image-20210109110715285.png" alt="image-20210109110715285" style="zoom:67%;" />

### 类加载器

#### **类加载器作用**

<img src="pictures/image-20210109110927264.png" alt="image-20210109110927264" style="zoom:67%;" />

1. 类加载器负责 **从文件系统或者网络中** 加载.class文件（class文件在文件开头有特定标识）

2. ClassLoader只负责class文件加载，至于它是否可以运行，得有 **执行引擎Execution Engine** 决定

   ![image-20210109111946045](pictures/image-20210109111946045.png)

3. 加载得类信息存放在称为 **方法区的内存空间**

   ![image-20210109112001658](pictures/image-20210109112001658.png)

#### **类加载器角色**

> .class文件加载到JVM中，作为元数据模板放在方法区。该过程需要一个 **运输工具扮演快递员** 的角色，即 ClassLoader。

#### **JVM类加载过程**

<img src="pictures/image-20210109112600233.png" alt="image-20210109112600233" style="zoom: 67%;" />

1. **加载（类加载器）**

   1. 通过一个**类的全限定名**获取定义此类的二进制字节流
   2. 将这个字节流所代表的**静态存储结构**转化为**方法区**的**运行时数据结构**
   3. 在内存堆中生成这个类的java.lang.**Class对象**，作为方法区这个类的各种数据的访问入口

   > 加载class文件方式有：本地系统、网络（Web Applet）、zip/jar/war、运行时计算生成.class文件（动态代理）

2. **链接**

   1. **验证：**确保字节流信息正确安全（文件格式、元数据、字节码、符号引用等验证） 

      > 二进制魔数：CAFE BABE		插件 jclass -> show byteCode 查看字节码

      <img src="pictures/image-20210109114927920.png" alt="image-20210109114927920" style="zoom: 67%;" />

   2. **准备：**为 **static类变量** 分配内存并且设置 **默认初始值**，即0

      > 注意：
      >
      > 1. 若是用final修饰的static，则因为final在编译的时候就分配值了，故 准备阶段 是 **显性初始化**
      > 2. 这里不会为 **实例变量** 分配初始化，**实例变量**是随着 **对象** 分配在堆中，类变量是在 **方法区** 中

      ```java
      public class Demo {
          private static int a = 1;  // 准备阶段为0，在初始化的时候才是1
          public static void main(String[] args) {
              System.out.println(a);
          }
      }
      ```

   3. **解析：**将常量池内的**符号引用（字符串标识）**转换为**直接引用（地址指针）**的过程

      > 事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行

3. **初始化**：**就是执行 类构造器方法\<clinit>() 的过程**

   + \<clinit>() 不需要自己定义，当我们代码中包含static变量的时候，就会有clinit方法。

   + \<clinit>() 是执行类变量的赋值动作和静态代码块的方法，按语句出现的顺序执行，先父类后子类

   + **类构造器方法\<clinit>() != 类的构造器\<init>**
   + 虚拟机的实现上必须保证 **类构造器方法\<clinit>()** 在多线程下被**同步加锁，只执行一次**。

#### **类加载器分类**

<img src="pictures/image-20210109135752969.png" alt="image-20210109135752969" style="zoom: 67%;" />

> 这里的四者间的双亲委派是 **包含关系**，不是上层和下层，**也不是继承关系**。

1. **引导类加载器，Bootstrap ClassLoader**

   > 1. 使用C/C++语言实现的，嵌套在JVM内部，不继承自Java.lang.ClassLoader，没有父加载器
   > 2. 加载 JAVAHOME/jre/1ib/rt.jar、resources.jar
   > 3. 出于安全考虑，Bootstrap只加载包名为java、javax、sun等开头的类

   <img src="pictures/image-20210109135520688.png" alt="image-20210109135520688" style="zoom:125%;" />

2. **扩展类加载器，Extension ClassLoader**

   > 1. Java语言编写，sun.misc.Launcher$ExtClassLoader，派生于ClassLoader类
   > 2. 加载 JAVAHOME/jre/1ib/ext

3. **应用类加载器，Apps ClassLoader**

   > 1. Java语言编写，sun.misc.Launcher$AppClassLoader，派生于ClassLoader类
   > 2. 它负责加载环境变量classpath路径下的类库
   > 3. 是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载

4. **用户自定义类加载器**

#### 双亲委派机制

<img src="pictures/image-20210109140948689.png" alt="image-20210109140948689" style="zoom:80%;" />

> 好处：
>
> 1. 避免类的重复加载（类加载器+类名），如自定义String类，调用main方法报错
> 2. 保护程序安全，如定义java.lang.MyString类，ClassLoader禁止加载java.lang前缀的类而报错

1. **双亲委派的例子 SPI**

   > 当我们加载jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI核心类（rt.jar），接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar的加载。

   <img src="pictures/image-20210109141227602.png" alt="image-20210109141227602" style="zoom: 67%;" />

2. **沙箱安全机制**

   > 自定义String类，并调用String类的main方法
   > 但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class）
   > 报错信息说没有main方法，就是因为加载的是rt.jar包中的String类
   > 这样可以保证对 **Java核心源代码** 的保护，这就是沙箱安全机制

#### 触发类加载时机

1. 创建类的实例
2. 创建类的子类实例
3. 访问某个类或接口的静态变量
4. 调用类的静态方法
5. 反射

### 运行时内存

<img src="pictures/image-20210109143636370.png" alt="image-20210109143636370" style="zoom: 67%;" />

> 内存是非常重要的系统资源，是硬盘和CPU的**中间仓库**，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。

> 当我们通过前面的：类的加载-> 验证 -> 准备 -> 解析 -> 初始化 这几个阶段完成后，就会用到 **执行引擎** 对类进行使用，同时执行引擎将会使用到 **运行时内存**

#### 程序计数器

> JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。这里，**并非是广义上所指的物理寄存器**，或许将其翻译为程序计数器会更加贴切

> **作用**：该内存区域用来存储指向下一条指令的地址，也即将要执行的指令代码。由**执行引擎**读取下一条指令

> 每个线程都有它自己的程序计数器，**是线程私有的（记录各个线程正在执行的当前字节码指令地址，才能实现多线程）**
> 它是唯一一个在Java虚拟机规范中没有规定任何outotMemoryError情况的区域

<img src="pictures/image-20210109144833513.png" alt="image-20210109144833513" style="zoom:80%;" />

#### 虚拟机栈

+ **概述**

  > 由于**跨平台性的设计**，Java的指令都是**根据栈来设计的**。不同平台CPU架构不同，所以**不能设计为基于寄存器的**。

  > 优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。

  > 栈是运行时的单位，而堆是存储的单位
  >
  > 1. 栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。
  > 2. 堆解决的是数据存储的问题，即数据怎么放，放哪里

  **每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个栈帧，对应着一次次Java方法调用**

  **栈是线程私有，生命周期和线程一致**

+ **栈帧结构**

  > **局部变量表**（Local Variables）
  > **操作数栈**（operand Stack）（表达式栈）
  > **动态链接**（DynamicLinking）（指向运行时常量池的方法引用）
  > **方法返回地址**（Return Address）（方法正常退出或者异常退出的定义）

  <img src="pictures/image-20210109153100636.png" alt="image-20210109153100636" style="zoom: 67%;" />

  > 虚拟机栈的操作只有两个：**进栈 / 出栈**
  >
  > 1. 每个方法执行，伴随着栈帧进栈
  > 2. 函数返回（return / throw）后栈帧出栈

  > **执行引擎** 运行的所有字节码指令只针对 **当前栈帧** 进行操作
  >
  > 如果在该方法中调用了其他方法，**对应的新的栈帧会被创建出来**，放在栈的顶端，成为**新的当前帧（压栈）**。

+ **内存溢出**

  + **StackoverflowError：**单线程内递归出不来，栈帧溢出

    > 可以使用参数 -Xss 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度

  + **OutofMemoryError：**多线程需要过多的虚拟机栈

1. **局部变量表**

2. **操作数栈**

3. **动态链接**

   <img src="pictures/image-20210116215428126.png" alt="image-20210116215428126" style="zoom:67%;" />

   > 每一个栈帧内部都包含一个指向 **运行时常量池** 中 **该栈帧** **所属方法的引用**
   >
   > 包含这个引用的目的就是为了支持 **当前方法** 的代码能够实现 **动态链接**（即当前方法可以调用其它方法）
   >
   > 描述一个方法调用了其他方法时，就是通过 **运行常量池** 中指向方法的符号引用来表示的，**动态链接作用是将符号引用转换直接引用**

   > 为什么需要运行常量池：因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，节省了空间

   > **方法调用**
   >
   > 在JVM中，将符号引用转换为调用方法的直接引用与**方法绑定机制**相关
   >
   > 绑定是一个字段、方法或者类在**符号引用**被替换为**直接引用**的过程，这仅仅**发生一次**。

   + **静态链接（早期绑定 / 非虚方法）**

     > 当一个字节码文件被**装载进JVM**内部时，如果**被调用的目标方法在编译期可知**，且运行期保持不变时，**在编译期**将调用方法的符号引用转换为直接引用的过程称之为静态链接

   + **动态链接（晚期绑定 / 虚方法）**

     > **如果被调用的方法在编译期无法被确定下来**，也就是说，只能够**在程序运行期将调用的方法的符号转换为直接引用**，由于这种引用转换过程具备动态性，因此也被称之为动态链接。

   > 对于虚方法（需要动态链接），如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。
   >
   > **为了提高性能**，JVM采用在类的 **方法区** 建立一个**虚方法表**（非虚方法不会出现在表中），使用索引表来代替查找
   >
   > **每个类** 中都有一个虚方法表，表中存放着各个方法的实际入口（直接指针），虚方法表会在 **类加载的链接阶段** 被创建并初始化

<img src="pictures/image-20210116222301205.png" alt="image-20210116222301205" style="zoom:110%;" />

4. **方法返回地址**：

   > 方法的退出就是当前栈帧出栈的过程：
   >
   > 1. 将返回值压入调用者栈帧的操作数栈
   > 2. 将方法返回地址写入PC寄存器

   + 方法正常退出时

     > 将**调用者调用时PC计数器**的值作为返回地址，即调用该方法的指令的下一条指令的地址

   + 方法异常退出时

     > 返回地址是要通过 **异常处理表** 来确定，该表不存在栈帧中  // todo where

+ 方法定义的局部变量是否线程安全？

  > 如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。

#### 本地方法栈

<img src="pictures/image-20210116225513376.png" alt="image-20210116225513376" style="zoom: 80%;" />

> 本地方法：即非Java代码的方法。定义本地方法**（关键字：native）**时并不提供实现体，实现体由非Java语言在外部实现。
>
> 虚拟机栈管理Java方法的调用；本地方法栈管理本地方法的调用。

#### 堆

<img src="pictures/image-20210117105150483.png" alt="image-20210117105150483" style="zoom:67%;" />



> **一个JVM进程** 只存在 **一个堆内存**，但是一个JVM进程包含多个线程
>
> **堆是线程共享**，是Java内存管理的核心区域

> 所有的**对象实例以及数组**都应当在运行时分配在堆上

> **栈帧只保存引用指针**，引用指向堆中的位置
>
> 方法结束后堆中对象不会马上移除（Stop the word 降低性能），得等到触发GC才回收

+ **逻辑分类**

  + 新生代（Eden + Survivor[to/from]  8:1:1）
  + 养老代
  + 永久代 1.7 / 元空间 1.8

  <img src="pictures/image-20210117110820175.png" alt="image-20210117110820175" style="zoom: 50%;" />

+ **设置堆内存大小**

  > Java堆区用于存储Java对象实例，堆的大小在JVM启动时就已经设定好

  + -Xms 用于表示堆区的 **起始内存**，等价于 -xx:InitialHeapSize（默认：电脑内存 / 64）
  + -Xmx 用于表示堆区的 **最大内存**，等价于 -xx:MaxHeapSize（默认：电脑内存 / 4）

  > **动态扩缩容：**
  >
  > 随着程序的执行，所需的堆空间越来越大，则会逐渐增大堆内存空间；当堆内存使用率降低，则会逐渐减小该内存区域的大小
  >
  > 🌕 通常会将 -Xms 和 -Xmx **配置相同值**，因为扩缩容前会执行GC，如果 -Xms 设置较小的话起初**会频繁 GC（1. STW 降低性能 2.GC后JVM重新规划内存，耗时）** 
  >
  > 堆内存使用超过 **-Xmx** 则抛出 **OutOfMemoryError** 异常

+ **新生代和老年代**

  > -XX: NewRatio  = 2   // 新生代 : 老年代 = 1 : 2
  >
  > -XX: SurvivorRatio = 8  // Eden : Survivor[to/from] = 8 : 1 : 1
  >
  > 为什么要分代：优化GC性能（不分代则整堆扫描效率低，分代的话由于大部分对象 **朝生夕死**，把新对象放同一块地方进行回收，可以腾出很大空间）

+ **对象分配过程**

  > 1. New的对象先放伊Eden。此区有大小限制
  > 2. 当Eden空间填满时，**触发MinorGC，进行新生代内存清理**（销毁不可达对象，并将剩余对象移动到 Suvivor F，并给对象设置年龄计数器。加一）
  > 3. 当Eden空间再次填满时，**触发MinorGC，进行新生代内存清理**（销毁不可达对象，并将新生代剩余对象移动到 Suvivor T，年龄加一）
  > 4. 当Suvivor **对象年龄** 到达 15 时，晋升老年代  //  -XX:MaxTenuringThreshold
  > 5. 当老年代内存不足时，**触发MajorGC，进行老年代内存清理** or **触发FullGC，进行整堆内存升级**
  > 6. 当执行了MajorGC / FullGC 之后，发现依然无法进行对象的保存，就会产生OOM异常

  <img src="pictures/image-20210221151437200.png" alt="image-20210221151437200" style="zoom:80%;" />

  > 分配原则：
  > 1. 优先分配到新生代 Eden
  > 2. 大对象直接分配老年代（尽量避免程序中出现过多大对象）
  > 3. 长期存活的对象分配到老年代
  > 4. 动态年龄判断（当新生代 Suvivor 相同年龄对象总和大于 Suvivor 空间一半时）

+ **TLAB: Thread Local Allocation Buffer**

  **堆内存都是线程共享的吗？ 不是的**

  > 共享内存上申请空间会产生 **指针冲突问题**，需要 **加锁同步**，此时效率下降。
  >
  > 故在堆中划分出一块区域 TLAB ，为每个线程分配一个私有缓冲区，包含在 Eden 空间内。
  >
  > -XX: UseTLAB  是否开启
  >
  > -XX:TLABWasteTargetPercent  TLAB 占 Eden 空间百分比

  **TLAB 分配过程**

  > 对象先通过TLAB开辟空间，如果不能放入，则通过Eden来进行分配

  <img src="pictures/image-20210221154421425.png" alt="image-20210221154421425" style="zoom: 67%;" />

+ **逃逸分析**

  **堆是分配对象的唯一选择吗？ 不是的**

  > JIT编译器 在 编译期间 根据 逃逸分析 的结果，如果对象并没有逃逸出方法，那么优化成栈上分配。这样无需在堆上分配内存，也无须进行垃圾回收。这也是最常见的堆外存储技术。（同时还会有 **锁消除** 的优化，降低 **线程同步** 开销）
  >
  > 如何分析：当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸，如果对象定义后在方法外部被调用则发生逃逸。

  <img src="pictures/image-20210221155433742.png" alt="image-20210221155433742" style="zoom: 100%;" />

  **分离对象和标量替换**

  > 在JIT阶段，如果经过逃逸分析，发现对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是使用标量（最小粒度）替换聚合量，节省空间。

  **逃逸分析的不足**

  > 其根本原因就是无法保证收益比。虽然经过逃逸分析可以做 **标量替换、栈上分配、和锁消除** ，但是逃逸分析自身需要复杂计算，这是相对耗时过程。



#### 方法区

> 方法区在 **逻辑上** 是属于堆的（**物理上不是**），但有的实现不会选择去进行垃圾收集或者进行压缩。目的就是要和堆分开。

<img src="pictures/image-20210221173408904.png" alt="image-20210221173408904" style="zoom:80%;" />

> 元空间与永久代最大的区别在于：元空间不在 **虚拟机设置内存** 中，而是使用 **本地内存**

**为什么用元数据区代替永久代 ？**

> 1. 为永久代设置空间最大限制是很难确定的，容易OOM；元空间使用的是本地内存。
> 2. 提高内存最大限制，可以降低 Full GC 频率

+ **设置方法区大小**

  **JDK7 永久代**

  >-XX:Permsize   初始大小
  >-XX:MaxPermsize   最大限制

  **JDK8 元数据区**

  >-XX:MetaspaceSize    初始大小
  >
  >-XX:MaxMetaspaceSize   最大限制   dft: -1 没有限制（尽可能用尽系统内存）

+ **方法区、堆、栈**



<img src="pictures/image-20210221172559546.png" alt="image-20210221172559546" style="zoom: 75%;" />

+ **方法区内部结构**

  <img src="pictures/image-20210221213331079.png" alt="image-20210221213331079" style="zoom: 60%;" />

  **方法区存储的内容**

  > 1. 类型信息（class / interface / enum / annotation）
  >
  >    全名 + 修饰符（public / abstract / final）+ 直接父类全名 + 直接接口列表
  >
  > 2. 域信息（变量信息）
  >
  >    类型的所有域的相关信息：域名称、域类型、域修饰符
  >
  > 3. 方法信息
  >
  >    方法名称 + 返回类型 + 参数数量和类型 + 异常表 + 修饰符 + 字节码 
  >
  > 4. 静态变量
  >
  >    类变量随着 **类的加载** 而加载，被类所有实例共享，即使没有实例时也可以访问
  >
  > 5. 全局变量 static final
  >
  >    final 修饰的 类变量在 **编译** 的时候就会被分配了 （编译 .class - 加载 .class）
  >
  > 6. 运行时常量池
  >
  >    JVM 加载类型（类或接口等）后维护的常量池，结构跟数组项相似，包含多种不同的常量。如编译期就明确的数值，和运行期解析后才能获得的方法或字段的引用。此时不再是字节码常量池种的符号地址了，而是真实地址。

  **运行时常量池 vs 字节码常量池**

  > 字节码常量池作用：
  >
  > .java文件编译后产生.class字节码文件。而字节码包含的 类型数据 过大，不能直接存到字节码里。故可以将数据存到常量池中，字节码包含指向常量池的**符号引用**。加载时动态链接，符号引用变成直接引用，指向运行时常量池

  <img src="pictures/image-20210221223735562.png" alt="image-20210221223735562" style="zoom:80%;" />

  ``` java
  public class MethodAreaTest2 {
      public static void main(String args[]) {
          Object obj = new Object();
      }
  }
  // 翻译成如下字节码
  // new #2  --> #2 是 符号引用
  // dup
  // invokespecial
  ```

+ **方法区垃圾回收**

  > 有些人认为方法区（元空间 / 永久代）没有垃圾收集，其实不准确。
  > JVM规范对方法区的约束是非常宽松的，提到可以不要求虚拟机在方法区中实现垃圾收集。
  > 事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。

  方法区垃圾收集主要两部分：不再使用的 **常量** 和 **类型**

#### 总结

<img src="pictures/image-20210222001904079.png" alt="image-20210222001904079" style="zoom: 67%;" />

**运行时数据区，是否存在Error和GC？**

| 运行时数据区 | 是否存在Error | 是否存在GC |
| ------------ | ------------- | ---------- |
| 程序计数器   | 否            | 否         |
| 虚拟机栈     | 是            | 否         |
| 本地方法栈   | 是            | 否         |
| 方法区       | 是（OOM）     | 是         |
| 堆           | 是            | 是         |