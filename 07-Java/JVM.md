https://gitee.com/moxi159753/LearningNotes/tree/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88

https://www.bilibili.com/video/BV1PJ411n7xZ?from=search&seid=15188220267839160314

## JVM

<img src="pictures/image-20210109110715285.png" alt="image-20210109110715285" style="zoom:67%;" />

### 类加载器

#### **类加载器作用**

<img src="pictures/image-20210109110927264.png" alt="image-20210109110927264" style="zoom:67%;" />

1. 类加载器负责 **从文件系统或者网络中** 加载.class文件（class文件在文件开头有特定标识）

2. ClassLoader只负责class文件加载，至于它是否可以运行，得有 **执行引擎Execution Engine** 决定

   ![image-20210109111946045](pictures/image-20210109111946045.png)

3. 加载得类信息存放在称为 **方法区的内存空间**

   ![image-20210109112001658](pictures/image-20210109112001658.png)

#### **类加载器角色**

> .class文件加载到JVM中，作为元数据模板放在方法区。该过程需要一个 **运输工具扮演快递员** 的角色，即 ClassLoader。

#### **JVM类加载过程**

<img src="pictures/image-20210109112600233.png" alt="image-20210109112600233" style="zoom: 67%;" />

1. **加载（类加载器）**

   1. 通过一个**类的全限定名**获取定义此类的二进制字节流
   2. 将这个字节流所代表的**静态存储结构**转化为**方法区**的**运行时数据结构**
   3. 在内存堆中生成这个类的java.lang.**Class对象**，作为方法区这个类的各种数据的访问入口

   > 加载class文件方式有：本地系统、网络（Web Applet）、zip/jar/war、运行时计算生成.class文件（动态代理）

2. **链接**

   1. **验证：**确保字节流信息正确安全（文件格式、元数据、字节码、符号引用等验证） 

      > 二进制魔数：CAFE BABE		插件 jclass -> show byteCode 查看字节码

      <img src="pictures/image-20210109114927920.png" alt="image-20210109114927920" style="zoom: 67%;" />

   2. **准备：**为 **static类变量** 分配内存并且设置 **默认初始值**，即0

      > 注意：
      >
      > 1. 若是用final修饰的static，则因为final在编译的时候就分配值了，故 准备阶段 是 **显性初始化**
      > 2. 这里不会为 **实例变量** 分配初始化，**实例变量**是随着 **对象** 分配在堆中，类变量是在 **方法区** 中

      ```java
      public class Demo {
          private static int a = 1;  // 准备阶段为0，在初始化的时候才是1
          public static void main(String[] args) {
              System.out.println(a);
          }
      }
      ```

   3. **解析：**将常量池内的**符号引用（字符串标识）**转换为**直接引用（地址指针）**的过程

      > 事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行

3. **初始化**：**就是执行 类构造器方法\<clinit>() 的过程**

   + \<clinit>() 不需要自己定义，当我们代码中包含static变量的时候，就会有clinit方法。

   + \<clinit>() 是执行类变量的赋值动作和静态代码块的方法，按语句出现的顺序执行，先父类后子类

   + **类构造器方法\<clinit>() != 类的构造器\<init>**
   + 虚拟机的实现上必须保证 **类构造器方法\<clinit>()** 在多线程下被**同步加锁，只执行一次**。

#### **类加载器分类**

<img src="pictures/image-20210109135752969.png" alt="image-20210109135752969" style="zoom: 67%;" />

> 这里的四者间的双亲委派是 **包含关系**，不是上层和下层，**也不是继承关系**。

1. **引导类加载器，Bootstrap ClassLoader**

   > 1. 使用C/C++语言实现的，嵌套在JVM内部，不继承自Java.lang.ClassLoader，没有父加载器
   > 2. 加载 JAVAHOME/jre/1ib/rt.jar、resources.jar
   > 3. 出于安全考虑，Bootstrap只加载包名为java、javax、sun等开头的类

   <img src="pictures/image-20210109135520688.png" alt="image-20210109135520688" style="zoom:125%;" />

2. **扩展类加载器，Extension ClassLoader**

   > 1. Java语言编写，sun.misc.Launcher$ExtClassLoader，派生于ClassLoader类
   > 2. 加载 JAVAHOME/jre/1ib/ext

3. **应用类加载器，Apps ClassLoader**

   > 1. Java语言编写，sun.misc.Launcher$AppClassLoader，派生于ClassLoader类
   > 2. 它负责加载环境变量classpath路径下的类库
   > 3. 是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载

4. **用户自定义类加载器**

#### 双亲委派机制

<img src="pictures/image-20210109140948689.png" alt="image-20210109140948689" style="zoom:80%;" />

> 好处：
>
> 1. 避免类的重复加载（类加载器+类名），如自定义String类，调用main方法报错
> 2. 保护程序安全，如定义java.lang.MyString类，ClassLoader禁止加载java.lang前缀的类而报错

1. **双亲委派的例子 SPI**

   > 当我们加载jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI核心类（rt.jar），接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar的加载。

   <img src="pictures/image-20210109141227602.png" alt="image-20210109141227602" style="zoom: 67%;" />

2. **沙箱安全机制**

   > 自定义String类，并调用String类的main方法
   > 但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class）
   > 报错信息说没有main方法，就是因为加载的是rt.jar包中的String类
   > 这样可以保证对 **Java核心源代码** 的保护，这就是沙箱安全机制

#### 触发类加载时机

1. 创建类的实例
2. 创建类的子类实例
3. 访问某个类或接口的静态变量
4. 调用类的静态方法
5. 反射

### 运行时内存

<img src="pictures/image-20210109143636370.png" alt="image-20210109143636370" style="zoom: 67%;" />

> 内存是非常重要的系统资源，是硬盘和CPU的**中间仓库**，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。

> 当我们通过前面的：类的加载-> 验证 -> 准备 -> 解析 -> 初始化 这几个阶段完成后，就会用到 **执行引擎** 对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区

#### 程序计数器

> JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。这里，**并非是广义上所指的物理寄存器**，或许将其翻译为程序计数器会更加贴切

> **作用**：该内存区域用来存储指向下一条指令的地址，也即将要执行的指令代码。由**执行引擎**读取下一条指令

> 每个线程都有它自己的程序计数器，**是线程私有的（记录各个线程正在执行的当前字节码指令地址，才能实现多线程）**
> 它是唯一一个在Java虚拟机规范中没有规定任何outotMemoryError情况的区域

<img src="pictures/image-20210109144833513.png" alt="image-20210109144833513" style="zoom:80%;" />

#### 虚拟机栈

+ **概述**

  > 由于**跨平台性的设计**，Java的指令都是**根据栈来设计的**。不同平台CPU架构不同，所以**不能设计为基于寄存器的**。

  > 优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。

  > 栈是运行时的单位，而堆是存储的单位
  >
  > 1. 栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。
  > 2. 堆解决的是数据存储的问题，即数据怎么放，放哪里

  **每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个栈帧，对应着一次次Java方法调用**

  **栈是线程私有，生命周期和线程一致**

+ **栈帧结构**

  > **局部变量表**（Local Variables）
  > **操作数栈**（operand Stack）（表达式栈）
  > **动态链接**（DynamicLinking）（指向运行时常量池的方法引用）
  > **方法返回地址**（Return Address）（方法正常退出或者异常退出的定义）

  <img src="pictures/image-20210109153100636.png" alt="image-20210109153100636" style="zoom: 67%;" />

  > 虚拟机栈的操作只有两个：**进栈 / 出栈**
  >
  > 1. 每个方法执行，伴随着栈帧进栈
  > 2. 函数返回（return / throw）后栈帧出栈

  > **执行引擎** 运行的所有字节码指令只针对 **当前栈帧** 进行操作
  >
  > 如果在该方法中调用了其他方法，**对应的新的栈帧会被创建出来**，放在栈的顶端，成为**新的当前帧（压栈）**。

+ **内存溢出**

  + **StackoverflowError：**单线程内递归出不来，栈帧溢出

    > 可以使用参数 -Xss 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度

  + **OutofMemoryError：**多线程需要过多的虚拟机栈

1. **局部变量表**

2. **操作数栈**

3. **动态链接**

   <img src="pictures/image-20210116215428126.png" alt="image-20210116215428126" style="zoom:67%;" />

   > 每一个栈帧内部都包含一个指向 **运行时常量池** 中 **该栈帧** **所属方法的引用**
   >
   > 包含这个引用的目的就是为了支持 **当前方法** 的代码能够实现 **动态链接**（即当前方法可以调用其它方法）
   >
   > 描述一个方法调用了其他方法时，就是通过 **运行常量池** 中指向方法的符号引用来表示的，**动态链接作用是将符号引用转换直接引用**

   > 为什么需要运行常量池：因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，节省了空间

   > **方法调用**
   >
   > 在JVM中，将符号引用转换为调用方法的直接引用与**方法绑定机制**相关
   >
   > 绑定是一个字段、方法或者类在**符号引用**被替换为**直接引用**的过程，这仅仅**发生一次**。

   + **静态链接（早期绑定 / 非虚方法）**

     > 当一个字节码文件被**装载进JVM**内部时，如果**被调用的目标方法在编译期可知**，且运行期保持不变时，**在编译期**将调用方法的符号引用转换为直接引用的过程称之为静态链接

   + **动态链接（晚期绑定 / 虚方法）**

     > **如果被调用的方法在编译期无法被确定下来**，也就是说，只能够**在程序运行期将调用的方法的符号转换为直接引用**，由于这种引用转换过程具备动态性，因此也被称之为动态链接。

   > 对于虚方法（需要动态链接），如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。
   >
   > **为了提高性能**，JVM采用在类的 **方法区** 建立一个**虚方法表**（非虚方法不会出现在表中），使用索引表来代替查找
   >
   > **每个类** 中都有一个虚方法表，表中存放着各个方法的实际入口（直接指针），虚方法表会在 **类加载的链接阶段** 被创建并初始化

<img src="pictures/image-20210116222301205.png" alt="image-20210116222301205" style="zoom:110%;" />

4. **方法返回地址**：

   > 方法的退出就是当前栈帧出栈的过程：
   >
   > 1. 将返回值压入调用者栈帧的操作数栈
   > 2. 将方法返回地址写入PC寄存器

   + 方法正常退出时

     > 将**调用者调用时PC计数器**的值作为返回地址，即调用该方法的指令的下一条指令的地址

   + 方法异常退出时

     > 返回地址是要通过 **异常处理表** 来确定，该表不存在栈帧中  // todo where

+ 方法定义的局部变量是否线程安全？

  > 如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。

#### 本地方法栈

<img src="pictures/image-20210116225513376.png" alt="image-20210116225513376" style="zoom: 80%;" />

> 本地方法：即非Java代码的方法。定义本地方法**（关键字：native）**时并不提供实现体，实现体由非Java语言在外部实现。
>
> 虚拟机栈管理Java方法的调用；本地方法栈管理本地方法的调用。

#### 堆

<img src="pictures/image-20210117105150483.png" alt="image-20210117105150483" style="zoom:67%;" />



> **一个JVM进程** 只存在 **一个堆内存**，但是一个JVM进程包含多个线程
>
> **堆是线程共享**，是Java内存管理的核心区域

> 所有的**对象实例以及数组**都应当在运行时分配在堆上

> **栈帧只保存引用指针**，引用指向堆中的位置
>
> 方法结束后堆中对象不会马上移除（Stop the word 降低性能），得等到触发GC才回收

+ 逻辑分类

  + 新生代（Eden + Survivor[to/from]  8:1:1）
  + 养老代
  + 永久代 1.7 / 元空间 1.8

  ![image-20210117110820175](pictures/image-20210117110820175.png)

+ 设置堆内存大小

  > Java堆区用于存储Java对象实例，堆的大小在JVM启动时就已经设定好

  + -Xms 用于表示堆区的 **起始内存**，等价于 -xx:InitialHeapSize（默认：电脑内存 / 64）
  + -Xmx 用于表示堆区的 **最大内存**，等价于 -xx:MaxHeapSize（默认：电脑内存 / 4）

  > **动态扩缩容：**
  >
  > 随着程序的执行，所需的堆空间越来越大，则会逐渐增大堆内存空间；当堆内存使用率降低，则会逐渐减小该内存区域的大小
  >
  > 🌕 通常会将 -Xms 和 -Xmx **配置相同值**，因为扩缩容前会执行GC，如果 -Xms 设置较小的话起初**会频繁 GC（1. STW 降低性能 2.GC后JVM重新规划内存，耗时）** 
  >
  > 堆内存使用超过 **-Xmx** 则抛出 **OutOfMemoryError** 异常

+ 



运行时数据区，是否存在Error和GC？

| 运行时数据区 | 是否存在Error | 是否存在GC |
| ------------ | ------------- | ---------- |
| 程序计数器   | 否            | 否         |
| 虚拟机栈     | 是            | 否         |
| 本地方法栈   | 是            | 否         |
| 方法区       | 是（OOM）     | 是         |
| 堆           | 是            | 是         |