#### 进程、线程、协程

+ 区别
+ 并行 vs 并发

+ 计算型任务（CPU密集型） vs 交互型任务（I/O密集型）

  





#### volatile

+ **why：**

  + **原子性：** 多个操作，要么全部执行**且执行过程不被打断**，要么被打断就都不执行

  + **可见性：**当多个线程访问同一变量时，一个线程修改了变量值，其它线程能**立刻感知到修改**

    +  Java 多线程的内存模型中，每个线程运行时开辟了缓存空间（解决主存读取速度慢的缺点），但使用缓存则会有 **缓存读写一致性** 问题。
    + 可见性得感知到修改后，从主存拿新数据，而不是从缓存拿旧数据

  + **有序性：**程序执行顺序按照代码的先后顺序执行**（包括多线程）**，阻止指令重排

    + JVM为提高程序执行效率，对**数据无依赖（只考虑单个线程下）的指令**进行**重排序**优化（编译器和处理器提高并行度）

    + 由于JVM只可分析单个线程下的数据依赖，故指令重排序不会影响单个线程的执行，但是**会影响到线程并发执行的正确性** 

    + JVM自带的有序性原则（happens-before）:

      > 程序次序规则：单线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作  
      >
      > 锁定规则：unLock操作先行发生于后面对同一个锁额lock操作  
      >
      > volatile变量规则：volatile修饰的变量，写操作先行发生于后面对这个变量的读操作  
      >
      > 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C  

+ **what：** 实现 **可见性 、有序性** 的关键字

+ **how**

  volatile汇编对应lock前缀指令，提供内存屏障功能

  + **实现可见性**：写操作强制立即写入主存，并使其它线程对应缓存行无效
  + **实现有序性**：阻止指令重排，屏障前后的指令**无法跨越屏障**进行重排

  

+ **单例模式（double check）**

  ``` java
  class Singleton {
      private volatile static Singleton instance = null;
      private Singleton() {}
      public static Singleton getInstance() {
          if(instance == null) {
              synchronized(Singleton.class) {
                  if(instance == null) {
                      instance = new Singleton(); // 开辟内存、初始化、指向引用
                  }
              }
          }
          return instance;
      }
  }
  ```



#### synchronized

+ **why、what：** 实现 **原子性、可见性、有序性** 的关键字

+ **how：**

  + **synchronized：monitor的不同实现（锁升级过程）**

    + **偏向锁：** monitor 使用对象头中的 mark word 存储了 **当前线程对象的指针** ，每次线程进来时，monitor检查该字段是否当前线程匹配，是则放行不走 加锁/解锁 流程，如果不是则升级轻量级锁。
    + **轻量锁（自旋）：**当线程尝试获取锁时，会在 **该线程的帧栈** 中分配个 **锁记录** 的空间，并把锁对象的 mark word 字段拷贝到锁记录中。进入同步块时，使用 CAS 尝试将锁对象的 mark word更新为 **锁记录空间** 的指针地址，成功则获得锁，失败则 **自旋重试**，重试多次后则升级重量锁
    + **重量锁：**CAS修改对象头 mark word，更新为指向互斥量的指针， 若失败无法获得锁则被 **挂起**，等待 **唤醒**，开启新一轮的锁竞争。

  + **object：对象头。monitor对其锁字段做标记**

    <img src="pictures/image-20210327115014488.png" alt="image-20210327115014488" style="zoom: 80%;" />

  + **threads：线程对象。monitor通过维护entryList、waitList队列，来管理线程对象**

    + **entryList：**竞争锁的队列。当新的线程进来时，首先与队头线程同时CAS竞争锁（非公平锁），成功则获得锁，失败则加入entryList尾部进行排队。
    + **waitList：**如果调用了**object.**wait() 方法，则当前获得锁的线程将 **归还锁**，进入waitlist 等待唤醒，唤醒后再开启新一轮的锁竞争。

    <img src="pictures/image-20210327162845142.png" alt="image-20210327162845142" style="zoom: 67%;" />



#### CAS

+ **why：**线程调度过程中，阻塞、唤醒（重量锁的互斥操作）开销大

+ **what：**无锁 / 乐观锁技术（乐观认为没有竞争，不加锁，等操作后发现有竞争再加重量锁）

+ **how：** compare and swap（CAS整个逻辑不是原子的（故会有 ABA 问题）)

  1. 线程从内存取值 V，并放入工作区缓存 A
  2. 对 A 进行进行业务计算，得出值 B
  3. compareAndSet 比较 A 值与现在内存的 V 值，若相等则将 B 值赋给内存 V；否则失败可自旋 （这里的compareAndSwap才是原子的）

  ```java
  class AtomicInteger {
      private volatile int value;   // 在无锁机制下需要用 volatile 保证线程间的数据是可见的（共享的）
      public final int get() {
          return value;
      }
      public final int incrementAndGet() {
          for(;;) {     // 无限循环直至成功
              int current = get();
              int next = current + 1;
              if(compareAndSwap(this, current, next)) return next;
          }
      }    
  }
  ```



#### AQS







#### Lock





#### Thread

+ **状态转换**

  ```java
  public enum State {
      NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED;
  }
  ```

  <img src="pictures/image-20210327165701003.png" alt="image-20210327165701003" style="zoom:67%;" />

  + New：新创建的一个线程，处于等待状态
  + Runnable：可运行状态，包含了 Ready、Running 两个状态，具体看 CPU 分配时间片
  + Timed_waiting：**指定时间** 内让出 CPU 资源 ，此时线程不会被执行，也不会被系统调度
  + Wating：**可被唤醒 **的等待状态，此时线程不会被执行，也不会被系统调度
  + Blocked：当发生**锁竞争状态**下，没有获得锁的线程会处于挂起状态
  + Terminated：终止状态，程序流程正常结束或者发生异常

+ **相关方法**
  + **Thread**：yield（让出 cpu，时间片重新调度）、join（让线程进入 wait ，当线程执行完毕后再 notify）、sleep
  + **Object**：wait、notify、notifyAll（会释放锁）





#### ThreadPool

+ **ThreadPoolExecutor**

  + **构造参数**

    + corePoolSize：核心池大小
    + maximumPoolSize：线程池最多能创建的线程数
    + keepAliveTime：线程没有任务执行时最多保持的生命时间（当线程数大于corePoolSize时才会生效）
    + workQueue：阻塞队列，存储等待执行的任务
      + LinkedBlockingQueue：基于链表的先进先出队列
      + Synchronous：不保存提交的任务，而是直接新建线程执行新来的任务
    + handler：当拒绝处理任务时的策略
      + ThreadPoolExecutor.AbortPolicy：丢弃任务并抛出异常
      + ThreadPoolExecutor.DiscardPolicy：丢弃任务但不抛出异常
      + ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复直至成功）
      + ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务

  + **重要方法**

    + execute()：向线程池提交任务，不返回执行结果
    + submit()：向线程池提交任务，能够返回执行结果 Future
    + shutdown()、shutdownNow()：关闭线程池  

  + **执行流程**

    1. 如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建新的线程去执行这个任务

    2. 如果当前线程池中的线程数目不小于corePoolSize，则每来一个任务，会尝试将其**添加到任务缓存队列**当中，若添加成功，则该任务会等待空闲线程将其取出去执行；**若添加失败（一般来说是任务缓存队列已满）**，则**会尝试创建新的线程**去执行这个任务
    3. 如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理  
    4. 如果线程池中的线程数量大于corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间（allowCoreThreadTimeOut），那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止









#### ThreadLocal









